{"ast":null,"code":"const GEOM_TYPES = ['points', 'lines', 'polygons'];\nexport function binaryToFeatureForAccesor(data, index) {\n  if (!data) {\n    return null;\n  }\n\n  const featureIndex = 'startIndices' in data ? data.startIndices[index] : index;\n  const geometryIndex = data.featureIds.value[featureIndex];\n\n  if (featureIndex !== -1) {\n    return getPropertiesForIndex(data, geometryIndex, featureIndex);\n  }\n\n  return null;\n}\n\nfunction getPropertiesForIndex(data, propertiesIndex, numericPropsIndex) {\n  const feature = {\n    properties: { ...data.properties[propertiesIndex]\n    }\n  };\n\n  for (const prop in data.numericProps) {\n    feature.properties[prop] = data.numericProps[prop].value[numericPropsIndex];\n  }\n\n  return feature;\n}\n\nexport function findIndexBinary(data, uniqueIdProperty, featureId) {\n  if (!data) {\n    return -1;\n  }\n\n  for (const gt of GEOM_TYPES) {\n    const index = findIndexByType(data, uniqueIdProperty, featureId, gt);\n\n    if (index !== -1) {\n      return index;\n    }\n  }\n\n  return -1;\n}\n\nfunction findIndexByType(data, uniqueIdProperty, featureId, geomType) {\n  if (!data) {\n    return -1;\n  }\n\n  if (!(geomType in data) || !data[geomType].positions.value.length) return -1;\n  let index = -1;\n\n  if (data[geomType].numericProps[uniqueIdProperty]) {\n    index = data[geomType].numericProps[uniqueIdProperty].value.indexOf(featureId);\n  } else {\n    const propertyIndex = data[geomType].properties.findIndex(elem => elem[uniqueIdProperty] === featureId);\n    index = data[geomType].featureIds.value.indexOf(propertyIndex);\n  }\n\n  return index;\n}\n\nexport function calculatePickingColors(geojsonBinary, encodePickingColor) {\n  const pickingColors = {\n    points: null,\n    lines: null,\n    polygons: null\n  };\n\n  for (const key in pickingColors) {\n    const featureIds = geojsonBinary[key].globalFeatureIds.value;\n    pickingColors[key] = new Uint8ClampedArray(featureIds.length * 3);\n    const pickingColor = [];\n\n    for (let i = 0; i < featureIds.length; i++) {\n      encodePickingColor(featureIds[i], pickingColor);\n      pickingColors[key][i * 3 + 0] = pickingColor[0];\n      pickingColors[key][i * 3 + 1] = pickingColor[1];\n      pickingColors[key][i * 3 + 2] = pickingColor[2];\n    }\n  }\n\n  return pickingColors;\n}","map":{"version":3,"sources":["../../../src/geojson-layer/geojson-binary.js"],"names":["GEOM_TYPES","featureIndex","data","geometryIndex","getPropertiesForIndex","feature","properties","index","findIndexByType","geomType","propertyIndex","elem","pickingColors","points","lines","polygons","featureIds","geojsonBinary","pickingColor","i","encodePickingColor"],"mappings":"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","sourcesContent":["// This module implement some utility functions to work with\n// the geojson-binary format defined at loaders.gl:\n// https://github.com/visgl/loaders.gl/blob/master/modules/gis/docs/api-reference/geojson-to-binary.md\n\nconst GEOM_TYPES = ['points', 'lines', 'polygons'];\n\n/**\n * Return the feature for an accesor\n *\n * @param {Object} data - The data in binary format\n * @param {Number} index - The requested index\n */\nexport function binaryToFeatureForAccesor(data, index) {\n  if (!data) {\n    return null;\n  }\n\n  const featureIndex = 'startIndices' in data ? data.startIndices[index] : index;\n  const geometryIndex = data.featureIds.value[featureIndex];\n\n  if (featureIndex !== -1) {\n    return getPropertiesForIndex(data, geometryIndex, featureIndex);\n  }\n\n  return null;\n}\n\nfunction getPropertiesForIndex(data, propertiesIndex, numericPropsIndex) {\n  const feature = {\n    properties: {...data.properties[propertiesIndex]}\n  };\n\n  for (const prop in data.numericProps) {\n    feature.properties[prop] = data.numericProps[prop].value[numericPropsIndex];\n  }\n\n  return feature;\n}\n\n/**\n * Return the index of feature (numericProps or featureIds) for given feature id\n * Example: findIndexBinary(data, 'id', 33) will return the index in the array of numericProps\n * of the feature 33.\n * @param {Object} data - The data in binary format\n * @param {String} uniqueIdProperty - Name of the unique id property\n * @param {Number} featureId - feature id to find\n */\nexport function findIndexBinary(data, uniqueIdProperty, featureId) {\n  if (!data) {\n    return -1;\n  }\n\n  for (const gt of GEOM_TYPES) {\n    const index = findIndexByType(data, uniqueIdProperty, featureId, gt);\n    if (index !== -1) {\n      return index;\n    }\n  }\n\n  return -1;\n}\n\nfunction findIndexByType(data, uniqueIdProperty, featureId, geomType) {\n  if (!data) {\n    return -1;\n  }\n\n  if (!(geomType in data) || !data[geomType].positions.value.length) return -1;\n\n  // Look for the uniqueIdProperty\n  let index = -1;\n  if (data[geomType].numericProps[uniqueIdProperty]) {\n    index = data[geomType].numericProps[uniqueIdProperty].value.indexOf(featureId);\n  } else {\n    const propertyIndex = data[geomType].properties.findIndex(\n      elem => elem[uniqueIdProperty] === featureId\n    );\n    index = data[geomType].featureIds.value.indexOf(propertyIndex);\n  }\n\n  return index;\n}\n\n// Custom picking color to keep binary indexes\nexport function calculatePickingColors(geojsonBinary, encodePickingColor) {\n  const pickingColors = {\n    points: null,\n    lines: null,\n    polygons: null\n  };\n  for (const key in pickingColors) {\n    const featureIds = geojsonBinary[key].globalFeatureIds.value;\n    pickingColors[key] = new Uint8ClampedArray(featureIds.length * 3);\n    const pickingColor = [];\n    for (let i = 0; i < featureIds.length; i++) {\n      encodePickingColor(featureIds[i], pickingColor);\n      pickingColors[key][i * 3 + 0] = pickingColor[0];\n      pickingColors[key][i * 3 + 1] = pickingColor[1];\n      pickingColors[key][i * 3 + 2] = pickingColor[2];\n    }\n  }\n\n  return pickingColors;\n}\n"]},"metadata":{},"sourceType":"module"}