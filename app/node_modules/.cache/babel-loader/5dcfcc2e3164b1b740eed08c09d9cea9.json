{"ast":null,"code":"import { Deck, WebMercatorViewport } from '@deck.gl/core';\nexport function getDeckInstance({\n  map,\n  gl,\n  deck\n}) {\n  if (map.__deck) {\n    return map.__deck;\n  }\n\n  const customRender = deck && deck.props._customRender;\n  const deckProps = {\n    useDevicePixels: true,\n    _customRender: () => {\n      map.triggerRepaint();\n\n      if (customRender) {\n        customRender();\n      }\n    },\n    parameters: {\n      depthMask: true,\n      depthTest: true,\n      blendFunc: [770, 771, 1, 771],\n      blendEquation: 32774\n    },\n    userData: {\n      isExternal: false,\n      mapboxLayers: new Set()\n    }\n  };\n\n  if (deck) {\n    deck.setProps(deckProps);\n    deck.props.userData.isExternal = true;\n  } else {\n    Object.assign(deckProps, {\n      gl,\n      width: false,\n      height: false,\n      touchAction: 'unset',\n      viewState: getViewState(map)\n    });\n    deck = new Deck(deckProps);\n    map.on('move', () => onMapMove(deck, map));\n    map.on('remove', () => {\n      deck.finalize();\n      map.__deck = null;\n    });\n  }\n\n  deck.props.userData.mapboxVersion = getMapboxVersion(map);\n  map.__deck = deck;\n  map.on('render', () => {\n    if (deck.layerManager) afterRender(deck, map);\n  });\n  return deck;\n}\nexport function addLayer(deck, layer) {\n  deck.props.userData.mapboxLayers.add(layer);\n  updateLayers(deck);\n}\nexport function removeLayer(deck, layer) {\n  deck.props.userData.mapboxLayers.delete(layer);\n  updateLayers(deck);\n}\nexport function updateLayer(deck, layer) {\n  updateLayers(deck);\n}\nexport function drawLayer(deck, map, layer) {\n  let {\n    currentViewport\n  } = deck.props.userData;\n\n  if (!currentViewport) {\n    currentViewport = getViewport(deck, map, true);\n    deck.props.userData.currentViewport = currentViewport;\n  }\n\n  if (!deck.layerManager) {\n    return;\n  }\n\n  deck._drawLayers('mapbox-repaint', {\n    viewports: [currentViewport],\n    layers: getLayers(deck, deckLayer => shouldDrawLayer(layer.id, deckLayer)),\n    clearCanvas: false\n  });\n}\n\nfunction getViewState(map) {\n  const {\n    lng,\n    lat\n  } = map.getCenter();\n  return {\n    longitude: lng,\n    latitude: lat,\n    zoom: map.getZoom(),\n    bearing: map.getBearing(),\n    pitch: map.getPitch()\n  };\n}\n\nfunction getMapboxVersion(map) {\n  let major = 0;\n  let minor = 0;\n\n  if (map.version) {\n    [major, minor] = map.version.split('.').slice(0, 2).map(Number);\n  }\n\n  return {\n    major,\n    minor\n  };\n}\n\nfunction getViewport(deck, map, useMapboxProjection = true) {\n  const {\n    mapboxVersion\n  } = deck.props.userData;\n  return new WebMercatorViewport(Object.assign({\n    x: 0,\n    y: 0,\n    width: deck.width,\n    height: deck.height,\n    repeat: true\n  }, getViewState(map), useMapboxProjection ? {\n    nearZMultiplier: mapboxVersion.major === 1 && mapboxVersion.minor >= 3 || mapboxVersion.major >= 2 ? 0.02 : 1 / (deck.height || 1)\n  } : {\n    nearZMultiplier: 0.1\n  }));\n}\n\nfunction afterRender(deck, map) {\n  const {\n    mapboxLayers,\n    isExternal\n  } = deck.props.userData;\n\n  if (isExternal) {\n    const mapboxLayerIds = Array.from(mapboxLayers, layer => layer.id);\n    const layers = getLayers(deck, deckLayer => {\n      for (const id of mapboxLayerIds) {\n        if (shouldDrawLayer(id, deckLayer)) {\n          return false;\n        }\n      }\n\n      return true;\n    });\n\n    if (layers.length > 0) {\n      deck._drawLayers('mapbox-repaint', {\n        viewports: [getViewport(deck, map, false)],\n        layers,\n        clearCanvas: false\n      });\n    }\n  }\n\n  deck.props.userData.currentViewport = null;\n}\n\nfunction onMapMove(deck, map) {\n  deck.setProps({\n    viewState: getViewState(map)\n  });\n  deck.needsRedraw({\n    clearRedrawFlags: true\n  });\n}\n\nfunction getLayers(deck, layerFilter) {\n  const layers = deck.layerManager.getLayers();\n  return layers.filter(layerFilter);\n}\n\nfunction shouldDrawLayer(id, layer) {\n  let layerInstance = layer;\n\n  while (layerInstance) {\n    if (layerInstance.id === id) {\n      return true;\n    }\n\n    layerInstance = layerInstance.parent;\n  }\n\n  return false;\n}\n\nfunction updateLayers(deck) {\n  if (deck.props.userData.isExternal) {\n    return;\n  }\n\n  const layers = [];\n  deck.props.userData.mapboxLayers.forEach(deckLayer => {\n    const LayerType = deckLayer.props.type;\n    const layer = new LayerType(deckLayer.props);\n    layers.push(layer);\n  });\n  deck.setProps({\n    layers\n  });\n}","map":{"version":3,"sources":["../../src/deck-utils.js"],"names":["deck","map","customRender","deckProps","useDevicePixels","_customRender","parameters","depthMask","depthTest","blendFunc","blendEquation","userData","isExternal","mapboxLayers","Object","width","height","touchAction","viewState","getViewState","onMapMove","getMapboxVersion","afterRender","updateLayers","currentViewport","getViewport","viewports","layers","getLayers","deckLayer","shouldDrawLayer","layer","clearCanvas","lat","longitude","latitude","zoom","bearing","pitch","major","minor","useMapboxProjection","mapboxVersion","x","y","repeat","nearZMultiplier","mapboxLayerIds","Array","clearRedrawFlags","layerInstance","LayerType"],"mappings":"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","sourcesContent":["import {Deck, WebMercatorViewport} from '@deck.gl/core';\n\nexport function getDeckInstance({map, gl, deck}) {\n  // Only create one deck instance per context\n  if (map.__deck) {\n    return map.__deck;\n  }\n\n  const customRender = deck && deck.props._customRender;\n\n  const deckProps = {\n    useDevicePixels: true,\n    _customRender: () => {\n      map.triggerRepaint();\n      if (customRender) {\n        // customRender may be subscribed by DeckGL React component to update child props\n        // make sure it is still called\n        customRender();\n      }\n    },\n    // TODO: import these defaults from a single source of truth\n    parameters: {\n      depthMask: true,\n      depthTest: true,\n      blendFunc: [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA],\n      blendEquation: gl.FUNC_ADD\n    },\n    userData: {\n      isExternal: false,\n      mapboxLayers: new Set()\n    }\n  };\n\n  if (deck) {\n    deck.setProps(deckProps);\n    deck.props.userData.isExternal = true;\n  } else {\n    // Using external gl context - do not set css size\n    Object.assign(deckProps, {\n      gl,\n      width: false,\n      height: false,\n      touchAction: 'unset',\n      viewState: getViewState(map)\n    });\n    deck = new Deck(deckProps);\n\n    // If deck is externally provided (React use case), we use deck's viewState to\n    // drive the map.\n    // Otherwise (pure JS use case), we use the map's viewState to drive deck.\n    map.on('move', () => onMapMove(deck, map));\n    map.on('remove', () => {\n      deck.finalize();\n      map.__deck = null;\n    });\n  }\n  deck.props.userData.mapboxVersion = getMapboxVersion(map);\n  map.__deck = deck;\n  map.on('render', () => {\n    if (deck.layerManager) afterRender(deck, map);\n  });\n\n  return deck;\n}\n\nexport function addLayer(deck, layer) {\n  deck.props.userData.mapboxLayers.add(layer);\n  updateLayers(deck);\n}\n\nexport function removeLayer(deck, layer) {\n  deck.props.userData.mapboxLayers.delete(layer);\n  updateLayers(deck);\n}\n\nexport function updateLayer(deck, layer) {\n  updateLayers(deck);\n}\n\nexport function drawLayer(deck, map, layer) {\n  let {currentViewport} = deck.props.userData;\n  if (!currentViewport) {\n    // This is the first layer drawn in this render cycle.\n    // Generate viewport from the current map state.\n    currentViewport = getViewport(deck, map, true);\n    deck.props.userData.currentViewport = currentViewport;\n  }\n  if (!deck.layerManager) {\n    return;\n  }\n  deck._drawLayers('mapbox-repaint', {\n    viewports: [currentViewport],\n    // TODO - accept layerFilter in drawLayers' renderOptions\n    layers: getLayers(deck, deckLayer => shouldDrawLayer(layer.id, deckLayer)),\n    clearCanvas: false\n  });\n}\n\nfunction getViewState(map) {\n  const {lng, lat} = map.getCenter();\n  return {\n    longitude: lng,\n    latitude: lat,\n    zoom: map.getZoom(),\n    bearing: map.getBearing(),\n    pitch: map.getPitch()\n  };\n}\n\nfunction getMapboxVersion(map) {\n  // parse mapbox version string\n  let major = 0;\n  let minor = 0;\n  if (map.version) {\n    [major, minor] = map.version\n      .split('.')\n      .slice(0, 2)\n      .map(Number);\n  }\n  return {major, minor};\n}\n\nfunction getViewport(deck, map, useMapboxProjection = true) {\n  const {mapboxVersion} = deck.props.userData;\n\n  return new WebMercatorViewport(\n    Object.assign(\n      {\n        x: 0,\n        y: 0,\n        width: deck.width,\n        height: deck.height,\n        repeat: true\n      },\n      getViewState(map),\n      useMapboxProjection\n        ? {\n            // match mapbox's projection matrix\n            // A change of near plane was made in 1.3.0\n            // https://github.com/mapbox/mapbox-gl-js/pull/8502\n            nearZMultiplier:\n              (mapboxVersion.major === 1 && mapboxVersion.minor >= 3) || mapboxVersion.major >= 2\n                ? 0.02\n                : 1 / (deck.height || 1)\n          }\n        : {\n            // use deck.gl's own default\n            nearZMultiplier: 0.1\n          }\n    )\n  );\n}\n\nfunction afterRender(deck, map) {\n  const {mapboxLayers, isExternal} = deck.props.userData;\n\n  if (isExternal) {\n    // Draw non-Mapbox layers\n    const mapboxLayerIds = Array.from(mapboxLayers, layer => layer.id);\n    const layers = getLayers(deck, deckLayer => {\n      for (const id of mapboxLayerIds) {\n        if (shouldDrawLayer(id, deckLayer)) {\n          return false;\n        }\n      }\n      return true;\n    });\n    if (layers.length > 0) {\n      deck._drawLayers('mapbox-repaint', {\n        viewports: [getViewport(deck, map, false)],\n        layers,\n        clearCanvas: false\n      });\n    }\n  }\n\n  // End of render cycle, clear generated viewport\n  deck.props.userData.currentViewport = null;\n}\n\nfunction onMapMove(deck, map) {\n  deck.setProps({\n    viewState: getViewState(map)\n  });\n  // Camera changed, will trigger a map repaint right after this\n  // Clear any change flag triggered by setting viewState so that deck does not request\n  // a second repaint\n  deck.needsRedraw({clearRedrawFlags: true});\n}\n\nfunction getLayers(deck, layerFilter) {\n  const layers = deck.layerManager.getLayers();\n  return layers.filter(layerFilter);\n}\n\nfunction shouldDrawLayer(id, layer) {\n  let layerInstance = layer;\n  while (layerInstance) {\n    if (layerInstance.id === id) {\n      return true;\n    }\n    layerInstance = layerInstance.parent;\n  }\n  return false;\n}\n\nfunction updateLayers(deck) {\n  if (deck.props.userData.isExternal) {\n    return;\n  }\n\n  const layers = [];\n  deck.props.userData.mapboxLayers.forEach(deckLayer => {\n    const LayerType = deckLayer.props.type;\n    const layer = new LayerType(deckLayer.props);\n    layers.push(layer);\n  });\n  deck.setProps({layers});\n}\n"]},"metadata":{},"sourceType":"module"}